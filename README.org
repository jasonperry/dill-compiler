*Dill* is a statically typed programming language to capture how
I want to write and read imperative code. It's meant to be
type- and memory-safe, with a good orthogonal set of type-based
abstractions, with as close to zero runtime overhead as possible. The
most interesting feature is how it makes mutability explicit and simplifies
management of the value/reference distinction. 
Goals and features include:
- "Imperative locally, functional-first globally"; being an imperative
  language, local variables are reassignable. But datatypes are
  immutable by default, and procedure arguments are passed immutably by
  default and are not reassignable.
- Non-local mutation is made explicit; passing an object mutably is
  indicated at both the function definition and call site. Otherwise
  objects have true ("deep") immutability.
- No implicit differences in behavior due to using values vs. references (the 
  explicit mutation helps with this.) 
  Values and references are distinguished in code only when it matters; for 
  example, a reference to part of a mutable object must be declared as a reference. 
- All statically-sized immutable objects are values. Dynamically-sized objects 
  are never implicitly copied.
- Struct and variant types, case pattern matching, recursive types
- All types are datatypes; there are no classes (containers for
  a type and methods), though method call syntax is planned. Method call
  syntax also distinguishes mutating and non-mutating functions.
- Null-safety with explicit nullable (option) types; syntax
  and value promotion convenience features
- Syntax: keywords are used to delineate blocks; curly braces are only
  for record expressions. Keywords should "do work" of clarifying
  structure, e.g. ~endif~ and not just ~end~. We try to be more
  concise than Pascal/Ada syntax, but readability is more
  important. Semicolons as statement terminators. Making code easy to
  type and even read aloud are also goals.
- Modules as the primary construct for code grouping and data
  hiding. "Private" means private to a module; functions in a
  module can access private fields of datatypes in that module. All
  imports must be explicitly specified.
- Separate compilation by means of auto-generated module
  specifications. This is strictly a compiler feature---module specs are
  not part of the language definition proper. What a module exposes is
  completely specified by its source.
- In progress: generics, with constraints by means of module signatures (the
  modular equivalent of interfaces). Module imports explicitly specify
  which signature implementations you're using.
- Possibly: coroutines, probably stackless. 

We'll see how far I get. The backend is LLVM with the Boehm garbage
collector, currently targeting only x86-64.

#+BEGIN_COMMENT
- Planned: passing procedure references. We'll see if it makes sense to
  go with full first-class/anonymous functions. If so, we'll introduce a
  pure function syntax and only allow those to be
  first-class. Procedures will never be nested.
#+END_COMMENT
