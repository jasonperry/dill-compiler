I'm working on a statically typed programming language that captures how
I want to write imperative code, with nice safety features and good
not-too-abstract abstractions. I'm also doing this to learn about
compiler design and test out some ideas in that area. Goals and features
include:
- "Keep mutation local"; being an imperative language, local variables
  are reassignable. But datatypes are immutable by default, and
  procedure arguments are passed immutably by default and not
  reassignable. Passing a mutable reference must be indicated at both
  the function definition and call site. Possibly this will allow for
  more useful types of static analysis, in addition to making the
  code's behavior clearer from the source.
- The explicit mutation tracking should mean that we can avoid
  distinguishing values from references in the source, without
  sacrificing efficiency. It's clear that languages should not have
  hidden differences in behavior that come from using value
  vs. reference types; I additionally feel that only low-level languages
  should require manual notation of references. The hope is that with
  mutation tracking, it will be straightforward for the compiler to
  determine that behavior will be correct and use values or references
  as appropriate for efficiency.
- Struct and variant types, generative type aliases
- All concrete types are datatypes; there are no classes (containers
  for a type and methods), though there is method call syntax. Method
  call syntax also distinguishes mutating and non-mutating methods.
- Null-safety with explicit nullable (option) types; syntax
  and value promotion convenience features
- Modules as the primary construct for code grouping and data
  hiding. "Private" only means private to a module; functions in a
  module can access private fields of datatypes in that module. All
  imports must be explicitly specified.
- Separate compilation by means of auto-generated module
  signatures. This is strictly a compiler feature, that is, signatures
  are not part of the language definition proper; what a module exposes
  is completely specified by its source.
- Keyword-based block syntax instead of curly braces. Some pains have
  been taken to be more concise than Pascal/Ada syntax, while still
  being more explicit about structure than, say, Ruby or Lua. Semicolons
  as statement terminators. "As readable as possible, as verbose as
  necessary." Making code easy to type is also a goal.
- Eventually: generics with interface constraints. One can code against
  concrete datatypes or interfaces, with type signatures that
  clearly distinguish between those cases.

We'll see how far I get. The initial backend is LLVM, with a current
target of x86_64.
