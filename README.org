I'm working on a statically typed programming language that captures how
I want to write imperative code, with nice safety features and good
not-too-abstract abstractions. I'm also doing this to learn about
compiler design and test out some ideas in that area. Goals and features
include:
- "Keep mutation local"; being an imperative language, local variables
  are reassignable. But datatypes are immutable by default, and
  procedure arguments are passed immutably by default and not
  reassignable. Passing a mutable reference must be indicated at both
  the function definition and call site. Possibly this will allow for
  more useful types of static analysis, in addition to making the
  code's behavior clearer from the source.
- The explicit mutation tracking should mean that we can avoid
  distinguishing values from references in the source, without
  sacrificing efficiency. It's clear that languages should not have
  hidden differences in behavior that come from using value
  vs. reference types; also, this language is meant to be higher-level
  than languages requiring manual notation of references. The hope is
  that with mutation tracking, it will be straightforward for the
  compiler to correctly use values or references as appropriate for
  efficiency.
- Struct and variant types, later: generative type aliases
- All concrete types are datatypes; there are no classes (containers
  for a type and methods), though there is method call syntax. Method
  call syntax also distinguishes mutating and non-mutating methods.
- Null-safety with explicit nullable (option) types; syntax
  and value promotion convenience features
- Modules as the primary construct for code grouping and data
  hiding. "Private" only means private to a module; functions in a
  module can access private fields of datatypes in that module. All
  imports must be explicitly specified.
- Separate compilation by means of auto-generated module
  signatures. This is strictly a compiler feature, that is, signatures
  are not part of the language definition proper; what a module exposes
  is completely specified by its source.
- Keyword-based block syntax instead of curly braces. Keywords should
  "do work" of clarifying structure, e.g. "endif" and not just
  "end". Still, we try to be more concise than Pascal/Ada
  syntax. Semicolons as statement terminators. "As readable as
  possible, as verbose as necessary." Making code easy to type and even
  pronounce are also goals.
- Planned: generics with interface constraints (interfaces to be called
  "abstypes")
- Planned: coroutines (probably stackless)

We'll see how far I get. The initial backend is LLVM, currently
targeting only x86_64.
